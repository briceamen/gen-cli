package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const commandTemplate = `// Code generated by generative-cli. DO NOT EDIT.
package commands

import (
	"context"
	"fmt"
	"os"

	"github.com/spf13/cobra"
	scalingo "github.com/Scalingo/go-scalingo/v8"

	"generative-cli/render"
)

{{range $cmd := .Commands}}
var {{$cmd.VarName}} = &cobra.Command{
	Use:   "{{$cmd.Use}}",
	Short: "{{$cmd.Short}}",
	RunE: func(cmd *cobra.Command, args []string) error {
		ctx := context.Background()

		client, err := scalingo.New(ctx, scalingo.ClientConfig{
			APIToken: os.Getenv("SCALINGO_API_TOKEN"),
			Region:   os.Getenv("SCALINGO_REGION"),
		})
		if err != nil {
			fmt.Println(render.RenderError(err))
			return err
		}
		{{range $cmd.FlagVars}}
		{{.Name}}, _ := cmd.Flags().Get{{.GetterType}}("{{.FlagName}}")
		{{end}}

		// Method: {{$cmd.MethodName}}
		// This is a generated stub - implement the actual SDK call
		_ = client
		{{range $cmd.FlagVars}}_ = {{.Name}}
		{{end}}
		fmt.Println(render.RenderInfo("Command '{{$cmd.Use}}' is not yet fully implemented"))
		fmt.Println(render.SubtitleStyle.Render("SDK method: client.{{$cmd.MethodName}}(...)"))
		return nil
	},
}

func init{{$cmd.VarName}}() {
	{{range $cmd.Flags}}
	{{$cmd.VarName}}.Flags().{{.Type}}("{{.Name}}", {{.Default}}, "{{.Usage}}")
	{{end}}
	{{$cmd.VarName}}.Flags().StringP("output", "o", "table", "Output format (table, json)")
}
{{end}}

// Register{{.ServiceName}}Commands registers all generated commands with the parent
func Register{{.ServiceName}}Commands(parent *cobra.Command) {
	serviceCmd := &cobra.Command{
		Use:   "{{.ServiceLower}}",
		Short: "{{.ServiceName}} operations",
	}
	{{range $cmd := .Commands}}
	init{{$cmd.VarName}}()
	serviceCmd.AddCommand({{$cmd.VarName}})
	{{end}}
	parent.AddCommand(serviceCmd)
}
`

// CommandDef represents a command to be generated
type CommandDef struct {
	VarName    string
	Use        string
	Short      string
	MethodName string
	MethodCall string
	HasParams  bool
	FlagVars   []FlagVar
	Flags      []FlagDef
}

// FlagVar represents a variable to read from flags
type FlagVar struct {
	Name       string
	FlagName   string
	GetterType string
}

// FlagDef represents a flag definition
type FlagDef struct {
	Name    string
	Type    string
	Default string
	Usage   string
}

// ServiceFile represents a generated service file
type ServiceFile struct {
	ServiceName  string
	ServiceLower string
	Commands     []CommandDef
}

const registerTemplate = `// Code generated by generative-cli. DO NOT EDIT.
package commands

import "github.com/spf13/cobra"

// RegisterAll registers all generated service commands with the parent command
func RegisterAll(parent *cobra.Command) {
{{range .}}	Register{{.}}Commands(parent)
{{end}}}
`

// GenerateCommands generates Go code for the given methods
func GenerateCommands(newMethods map[string][]Method, outputPath string) error {
	if err := os.MkdirAll(outputPath, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	tmpl, err := template.New("command").Parse(commandTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var serviceNames []string

	for serviceName, methods := range newMethods {
		serviceNames = append(serviceNames, serviceName)

		sf := ServiceFile{
			ServiceName:  serviceName,
			ServiceLower: toSnakeCase(strings.TrimSuffix(serviceName, "Service")),
		}

		for _, method := range methods {
			cmd := methodToCommand(serviceName, method)
			sf.Commands = append(sf.Commands, cmd)
		}

		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, sf); err != nil {
			return fmt.Errorf("failed to execute template for %s: %w", serviceName, err)
		}

		// Format the code
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			// If formatting fails, write unformatted for debugging
			formatted = buf.Bytes()
		}

		filename := filepath.Join(outputPath, toSnakeCase(strings.TrimSuffix(serviceName, "Service"))+".go")
		if err := os.WriteFile(filename, formatted, 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", filename, err)
		}
	}

	// Generate register.go
	regTmpl, err := template.New("register").Parse(registerTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse register template: %w", err)
	}

	var buf bytes.Buffer
	if err := regTmpl.Execute(&buf, serviceNames); err != nil {
		return fmt.Errorf("failed to execute register template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		formatted = buf.Bytes()
	}

	if err := os.WriteFile(filepath.Join(outputPath, "register.go"), formatted, 0644); err != nil {
		return fmt.Errorf("failed to write register.go: %w", err)
	}

	return nil
}

func methodToCommand(serviceName string, method Method) CommandDef {
	// Convert method name to command use
	// e.g., AppsList -> list, AppsCreate -> create
	prefix := strings.TrimSuffix(serviceName, "Service")
	use := strings.TrimPrefix(method.Name, prefix)
	use = toKebabCase(use)

	// Handle case where method name equals service prefix (e.g., Logs -> Logs)
	if use == "" {
		use = "run"
	}

	// Include service name in var to avoid conflicts between services
	varPrefix := toCamelCase(strings.TrimSuffix(serviceName, "Service"))

	cmd := CommandDef{
		VarName:    varPrefix + toPascalCase(use) + "Cmd",
		Use:        use,
		Short:      fmt.Sprintf("%s %s", prefix, use),
		MethodName: method.Name,
		HasParams:  len(method.Params) > 0,
	}

	// Build method call
	var callParams []string
	callParams = append(callParams, "ctx")

	for _, param := range method.Params {
		flag := paramToFlag(param)
		cmd.Flags = append(cmd.Flags, flag)

		fv := FlagVar{
			Name:       toCamelCase(param.Name),
			FlagName:   toKebabCase(param.Name),
			GetterType: flagGetterType(param.Type),
		}
		cmd.FlagVars = append(cmd.FlagVars, fv)
		callParams = append(callParams, toCamelCase(param.Name))
	}

	cmd.MethodCall = fmt.Sprintf("%s(%s)", method.Name, strings.Join(callParams, ", "))

	return cmd
}

func paramToFlag(param Param) FlagDef {
	flag := FlagDef{
		Name:  toKebabCase(param.Name),
		Usage: fmt.Sprintf("%s parameter", param.Name),
	}

	switch param.Type {
	case "string":
		flag.Type = "String"
		flag.Default = `""`
	case "int", "int64":
		flag.Type = "Int"
		flag.Default = "0"
	case "bool":
		flag.Type = "Bool"
		flag.Default = "false"
	default:
		// For complex types, use string and let user provide JSON
		flag.Type = "String"
		flag.Default = `""`
		flag.Usage = fmt.Sprintf("%s (JSON format)", param.Name)
	}

	return flag
}

func flagGetterType(paramType string) string {
	switch paramType {
	case "string":
		return "String"
	case "int", "int64":
		return "Int"
	case "bool":
		return "Bool"
	default:
		return "String"
	}
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func toKebabCase(s string) string {
	return strings.ReplaceAll(toSnakeCase(s), "_", "-")
}

func toCamelCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func toPascalCase(s string) string {
	if s == "" {
		return s
	}
	// Convert kebab-case to PascalCase
	parts := strings.Split(s, "-")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
